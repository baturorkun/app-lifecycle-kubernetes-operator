
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1alpha1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/baturorkun/app-lifecycle-kubernetes-operator/api/v1alpha1/namespacelifecyclepolicy_types.go (0.0%)</option>
				
				<option value="file1">github.com/baturorkun/app-lifecycle-kubernetes-operator/api/v1alpha1/zz_generated.deepcopy.go (0.0%)</option>
				
				<option value="file2">github.com/baturorkun/app-lifecycle-kubernetes-operator/cmd/main.go (0.0%)</option>
				
				<option value="file3">github.com/baturorkun/app-lifecycle-kubernetes-operator/internal/controller/namespacelifecyclepolicy_controller.go (66.7%)</option>
				
				<option value="file4">github.com/baturorkun/app-lifecycle-kubernetes-operator/test/utils/utils.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// EDIT THIS FILE!  THIS IS SCAFFOLDING FOR YOU TO OWN!
// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.

// NamespaceLifecyclePolicySpec defines the desired state of NamespaceLifecyclePolicy
type NamespaceLifecyclePolicySpec struct {
        // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
        // Important: Run "make" to regenerate code after modifying this file
        // The following markers will use OpenAPI v3 schema to validate the value
        // More info: https://book.kubebuilder.io/reference/markers/crd-validation.html

        // foo is an example field of NamespaceLifecyclePolicy. Edit namespacelifecyclepolicy_types.go to remove/update
        // +optional
        Foo *string `json:"foo,omitempty"`
}

// NamespaceLifecyclePolicyStatus defines the observed state of NamespaceLifecyclePolicy.
type NamespaceLifecyclePolicyStatus struct {
        // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
        // Important: Run "make" to regenerate code after modifying this file

        // For Kubernetes API conventions, see:
        // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties

        // conditions represent the current state of the NamespaceLifecyclePolicy resource.
        // Each condition has a unique type and reflects the status of a specific aspect of the resource.
        //
        // Standard condition types include:
        // - "Available": the resource is fully functional
        // - "Progressing": the resource is being created or updated
        // - "Degraded": the resource failed to reach or maintain its desired state
        //
        // The status of each condition is one of True, False, or Unknown.
        // +listType=map
        // +listMapKey=type
        // +optional
        Conditions []metav1.Condition `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status

// NamespaceLifecyclePolicy is the Schema for the namespacelifecyclepolicies API
type NamespaceLifecyclePolicy struct {
        metav1.TypeMeta `json:",inline"`

        // metadata is a standard object metadata
        // +optional
        metav1.ObjectMeta `json:"metadata,omitzero"`

        // spec defines the desired state of NamespaceLifecyclePolicy
        // +required
        Spec NamespaceLifecyclePolicySpec `json:"spec"`

        // status defines the observed state of NamespaceLifecyclePolicy
        // +optional
        Status NamespaceLifecyclePolicyStatus `json:"status,omitzero"`
}

// +kubebuilder:object:root=true

// NamespaceLifecyclePolicyList contains a list of NamespaceLifecyclePolicy
type NamespaceLifecyclePolicyList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitzero"`
        Items           []NamespaceLifecyclePolicy `json:"items"`
}

func init() <span class="cov0" title="0">{
        SchemeBuilder.Register(&amp;NamespaceLifecyclePolicy{}, &amp;NamespaceLifecyclePolicyList{})
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">//go:build !ignore_autogenerated

/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
        "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NamespaceLifecyclePolicy) DeepCopyInto(out *NamespaceLifecyclePolicy) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamespaceLifecyclePolicy.
func (in *NamespaceLifecyclePolicy) DeepCopy() *NamespaceLifecyclePolicy <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NamespaceLifecyclePolicy)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NamespaceLifecyclePolicy) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NamespaceLifecyclePolicyList) DeepCopyInto(out *NamespaceLifecyclePolicyList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]NamespaceLifecyclePolicy, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamespaceLifecyclePolicyList.
func (in *NamespaceLifecyclePolicyList) DeepCopy() *NamespaceLifecyclePolicyList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NamespaceLifecyclePolicyList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NamespaceLifecyclePolicyList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NamespaceLifecyclePolicySpec) DeepCopyInto(out *NamespaceLifecyclePolicySpec) <span class="cov0" title="0">{
        *out = *in
        if in.Foo != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Foo, &amp;out.Foo
                *out = new(string)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamespaceLifecyclePolicySpec.
func (in *NamespaceLifecyclePolicySpec) DeepCopy() *NamespaceLifecyclePolicySpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NamespaceLifecyclePolicySpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NamespaceLifecyclePolicyStatus) DeepCopyInto(out *NamespaceLifecyclePolicyStatus) <span class="cov0" title="0">{
        *out = *in
        if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make([]v1.Condition, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NamespaceLifecyclePolicyStatus.
func (in *NamespaceLifecyclePolicyStatus) DeepCopy() *NamespaceLifecyclePolicyStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(NamespaceLifecyclePolicyStatus)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "crypto/tls"
        "flag"
        "os"

        // Import all Kubernetes client auth plugins (e.g. Azure, GCP, OIDC, etc.)
        // to ensure that exec-entrypoint and run can make use of them.
        _ "k8s.io/client-go/plugin/pkg/client/auth"

        "k8s.io/apimachinery/pkg/runtime"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        "sigs.k8s.io/controller-runtime/pkg/log/zap"
        "sigs.k8s.io/controller-runtime/pkg/metrics/filters"
        metricsserver "sigs.k8s.io/controller-runtime/pkg/metrics/server"
        "sigs.k8s.io/controller-runtime/pkg/webhook"

        appsv1alpha1 "github.com/baturorkun/app-lifecycle-kubernetes-operator/api/v1alpha1"
        "github.com/baturorkun/app-lifecycle-kubernetes-operator/internal/controller"
        // +kubebuilder:scaffold:imports
)

var (
        scheme   = runtime.NewScheme()
        setupLog = ctrl.Log.WithName("setup")
)

func init() <span class="cov0" title="0">{
        utilruntime.Must(clientgoscheme.AddToScheme(scheme))

        utilruntime.Must(appsv1alpha1.AddToScheme(scheme))
        // +kubebuilder:scaffold:scheme
}</span>

// nolint:gocyclo
func main() <span class="cov0" title="0">{
        var metricsAddr string
        var metricsCertPath, metricsCertName, metricsCertKey string
        var webhookCertPath, webhookCertName, webhookCertKey string
        var enableLeaderElection bool
        var probeAddr string
        var secureMetrics bool
        var enableHTTP2 bool
        var tlsOpts []func(*tls.Config)
        flag.StringVar(&amp;metricsAddr, "metrics-bind-address", "0", "The address the metrics endpoint binds to. "+
                "Use :8443 for HTTPS or :8080 for HTTP, or leave as 0 to disable the metrics service.")
        flag.StringVar(&amp;probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")
        flag.BoolVar(&amp;enableLeaderElection, "leader-elect", false,
                "Enable leader election for controller manager. "+
                        "Enabling this will ensure there is only one active controller manager.")
        flag.BoolVar(&amp;secureMetrics, "metrics-secure", true,
                "If set, the metrics endpoint is served securely via HTTPS. Use --metrics-secure=false to use HTTP instead.")
        flag.StringVar(&amp;webhookCertPath, "webhook-cert-path", "", "The directory that contains the webhook certificate.")
        flag.StringVar(&amp;webhookCertName, "webhook-cert-name", "tls.crt", "The name of the webhook certificate file.")
        flag.StringVar(&amp;webhookCertKey, "webhook-cert-key", "tls.key", "The name of the webhook key file.")
        flag.StringVar(&amp;metricsCertPath, "metrics-cert-path", "",
                "The directory that contains the metrics server certificate.")
        flag.StringVar(&amp;metricsCertName, "metrics-cert-name", "tls.crt", "The name of the metrics server certificate file.")
        flag.StringVar(&amp;metricsCertKey, "metrics-cert-key", "tls.key", "The name of the metrics server key file.")
        flag.BoolVar(&amp;enableHTTP2, "enable-http2", false,
                "If set, HTTP/2 will be enabled for the metrics and webhook servers")
        opts := zap.Options{
                Development: true,
        }
        opts.BindFlags(flag.CommandLine)
        flag.Parse()

        ctrl.SetLogger(zap.New(zap.UseFlagOptions(&amp;opts)))

        // if the enable-http2 flag is false (the default), http/2 should be disabled
        // due to its vulnerabilities. More specifically, disabling http/2 will
        // prevent from being vulnerable to the HTTP/2 Stream Cancellation and
        // Rapid Reset CVEs. For more information see:
        // - https://github.com/advisories/GHSA-qppj-fm5r-hxr3
        // - https://github.com/advisories/GHSA-4374-p667-p6c8
        disableHTTP2 := func(c *tls.Config) </span><span class="cov0" title="0">{
                setupLog.Info("disabling http/2")
                c.NextProtos = []string{"http/1.1"}
        }</span>

        <span class="cov0" title="0">if !enableHTTP2 </span><span class="cov0" title="0">{
                tlsOpts = append(tlsOpts, disableHTTP2)
        }</span>

        // Initial webhook TLS options
        <span class="cov0" title="0">webhookTLSOpts := tlsOpts
        webhookServerOptions := webhook.Options{
                TLSOpts: webhookTLSOpts,
        }

        if len(webhookCertPath) &gt; 0 </span><span class="cov0" title="0">{
                setupLog.Info("Initializing webhook certificate watcher using provided certificates",
                        "webhook-cert-path", webhookCertPath, "webhook-cert-name", webhookCertName, "webhook-cert-key", webhookCertKey)

                webhookServerOptions.CertDir = webhookCertPath
                webhookServerOptions.CertName = webhookCertName
                webhookServerOptions.KeyName = webhookCertKey
        }</span>

        <span class="cov0" title="0">webhookServer := webhook.NewServer(webhookServerOptions)

        // Metrics endpoint is enabled in 'config/default/kustomization.yaml'. The Metrics options configure the server.
        // More info:
        // - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.22.4/pkg/metrics/server
        // - https://book.kubebuilder.io/reference/metrics.html
        metricsServerOptions := metricsserver.Options{
                BindAddress:   metricsAddr,
                SecureServing: secureMetrics,
                TLSOpts:       tlsOpts,
        }

        if secureMetrics </span><span class="cov0" title="0">{
                // FilterProvider is used to protect the metrics endpoint with authn/authz.
                // These configurations ensure that only authorized users and service accounts
                // can access the metrics endpoint. The RBAC are configured in 'config/rbac/kustomization.yaml'. More info:
                // https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.22.4/pkg/metrics/filters#WithAuthenticationAndAuthorization
                metricsServerOptions.FilterProvider = filters.WithAuthenticationAndAuthorization
        }</span>

        // If the certificate is not specified, controller-runtime will automatically
        // generate self-signed certificates for the metrics server. While convenient for development and testing,
        // this setup is not recommended for production.
        //
        // TODO(user): If you enable certManager, uncomment the following lines:
        // - [METRICS-WITH-CERTS] at config/default/kustomization.yaml to generate and use certificates
        // managed by cert-manager for the metrics server.
        // - [PROMETHEUS-WITH-CERTS] at config/prometheus/kustomization.yaml for TLS certification.
        <span class="cov0" title="0">if len(metricsCertPath) &gt; 0 </span><span class="cov0" title="0">{
                setupLog.Info("Initializing metrics certificate watcher using provided certificates",
                        "metrics-cert-path", metricsCertPath, "metrics-cert-name", metricsCertName, "metrics-cert-key", metricsCertKey)

                metricsServerOptions.CertDir = metricsCertPath
                metricsServerOptions.CertName = metricsCertName
                metricsServerOptions.KeyName = metricsCertKey
        }</span>

        <span class="cov0" title="0">mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
                Scheme:                 scheme,
                Metrics:                metricsServerOptions,
                WebhookServer:          webhookServer,
                HealthProbeBindAddress: probeAddr,
                LeaderElection:         enableLeaderElection,
                LeaderElectionID:       "c9271d08.ops.dev",
                // LeaderElectionReleaseOnCancel defines if the leader should step down voluntarily
                // when the Manager ends. This requires the binary to immediately end when the
                // Manager is stopped, otherwise, this setting is unsafe. Setting this significantly
                // speeds up voluntary leader transitions as the new leader don't have to wait
                // LeaseDuration time first.
                //
                // In the default scaffold provided, the program ends immediately after
                // the manager stops, so would be fine to enable this option. However,
                // if you are doing or is intended to do any operation such as perform cleanups
                // after the manager stops then its usage might be unsafe.
                // LeaderElectionReleaseOnCancel: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to start manager")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err := (&amp;controller.NamespaceLifecyclePolicyReconciler{
                Client: mgr.GetClient(),
                Scheme: mgr.GetScheme(),
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", "NamespaceLifecyclePolicy")
                os.Exit(1)
        }</span>
        // +kubebuilder:scaffold:builder

        <span class="cov0" title="0">if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up health check")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if err := mgr.AddReadyzCheck("readyz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up ready check")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">setupLog.Info("starting manager")
        if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "problem running manager")
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
        "context"

        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        appsv1alpha1 "github.com/baturorkun/app-lifecycle-kubernetes-operator/api/v1alpha1"
)

// NamespaceLifecyclePolicyReconciler reconciles a NamespaceLifecyclePolicy object
type NamespaceLifecyclePolicyReconciler struct {
        client.Client
        Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=apps.ops.dev,resources=namespacelifecyclepolicies,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=apps.ops.dev,resources=namespacelifecyclepolicies/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps.ops.dev,resources=namespacelifecyclepolicies/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the NamespaceLifecyclePolicy object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.22.4/pkg/reconcile
func (r *NamespaceLifecyclePolicyReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        _ = logf.FromContext(ctx)

        // TODO(user): your logic here

        return ctrl.Result{}, nil
}</span>

// SetupWithManager sets up the controller with the Manager.
func (r *NamespaceLifecyclePolicyReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;appsv1alpha1.NamespaceLifecyclePolicy{}).
                Named("namespacelifecyclepolicy").
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package utils

import (
        "bufio"
        "bytes"
        "fmt"
        "os"
        "os/exec"
        "strings"

        . "github.com/onsi/ginkgo/v2" // nolint:revive,staticcheck
)

const (
        certmanagerVersion = "v1.19.1"
        certmanagerURLTmpl = "https://github.com/cert-manager/cert-manager/releases/download/%s/cert-manager.yaml"

        defaultKindBinary  = "kind"
        defaultKindCluster = "kind"
)

func warnError(err error) <span class="cov0" title="0">{
        _, _ = fmt.Fprintf(GinkgoWriter, "warning: %v\n", err)
}</span>

// Run executes the provided command within this context
func Run(cmd *exec.Cmd) (string, error) <span class="cov0" title="0">{
        dir, _ := GetProjectDir()
        cmd.Dir = dir

        if err := os.Chdir(cmd.Dir); err != nil </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(GinkgoWriter, "chdir dir: %q\n", err)
        }</span>

        <span class="cov0" title="0">cmd.Env = append(os.Environ(), "GO111MODULE=on")
        command := strings.Join(cmd.Args, " ")
        _, _ = fmt.Fprintf(GinkgoWriter, "running: %q\n", command)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return string(output), fmt.Errorf("%q failed with error %q: %w", command, string(output), err)
        }</span>

        <span class="cov0" title="0">return string(output), nil</span>
}

// UninstallCertManager uninstalls the cert manager
func UninstallCertManager() <span class="cov0" title="0">{
        url := fmt.Sprintf(certmanagerURLTmpl, certmanagerVersion)
        cmd := exec.Command("kubectl", "delete", "-f", url)
        if _, err := Run(cmd); err != nil </span><span class="cov0" title="0">{
                warnError(err)
        }</span>

        // Delete leftover leases in kube-system (not cleaned by default)
        <span class="cov0" title="0">kubeSystemLeases := []string{
                "cert-manager-cainjector-leader-election",
                "cert-manager-controller",
        }
        for _, lease := range kubeSystemLeases </span><span class="cov0" title="0">{
                cmd = exec.Command("kubectl", "delete", "lease", lease,
                        "-n", "kube-system", "--ignore-not-found", "--force", "--grace-period=0")
                if _, err := Run(cmd); err != nil </span><span class="cov0" title="0">{
                        warnError(err)
                }</span>
        }
}

// InstallCertManager installs the cert manager bundle.
func InstallCertManager() error <span class="cov0" title="0">{
        url := fmt.Sprintf(certmanagerURLTmpl, certmanagerVersion)
        cmd := exec.Command("kubectl", "apply", "-f", url)
        if _, err := Run(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Wait for cert-manager-webhook to be ready, which can take time if cert-manager
        // was re-installed after uninstalling on a cluster.
        <span class="cov0" title="0">cmd = exec.Command("kubectl", "wait", "deployment.apps/cert-manager-webhook",
                "--for", "condition=Available",
                "--namespace", "cert-manager",
                "--timeout", "5m",
        )

        _, err := Run(cmd)
        return err</span>
}

// IsCertManagerCRDsInstalled checks if any Cert Manager CRDs are installed
// by verifying the existence of key CRDs related to Cert Manager.
func IsCertManagerCRDsInstalled() bool <span class="cov0" title="0">{
        // List of common Cert Manager CRDs
        certManagerCRDs := []string{
                "certificates.cert-manager.io",
                "issuers.cert-manager.io",
                "clusterissuers.cert-manager.io",
                "certificaterequests.cert-manager.io",
                "orders.acme.cert-manager.io",
                "challenges.acme.cert-manager.io",
        }

        // Execute the kubectl command to get all CRDs
        cmd := exec.Command("kubectl", "get", "crds")
        output, err := Run(cmd)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if any of the Cert Manager CRDs are present
        <span class="cov0" title="0">crdList := GetNonEmptyLines(output)
        for _, crd := range certManagerCRDs </span><span class="cov0" title="0">{
                for _, line := range crdList </span><span class="cov0" title="0">{
                        if strings.Contains(line, crd) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// LoadImageToKindClusterWithName loads a local docker image to the kind cluster
func LoadImageToKindClusterWithName(name string) error <span class="cov0" title="0">{
        cluster := defaultKindCluster
        if v, ok := os.LookupEnv("KIND_CLUSTER"); ok </span><span class="cov0" title="0">{
                cluster = v
        }</span>
        <span class="cov0" title="0">kindOptions := []string{"load", "docker-image", name, "--name", cluster}
        kindBinary := defaultKindBinary
        if v, ok := os.LookupEnv("KIND"); ok </span><span class="cov0" title="0">{
                kindBinary = v
        }</span>
        <span class="cov0" title="0">cmd := exec.Command(kindBinary, kindOptions...)
        _, err := Run(cmd)
        return err</span>
}

// GetNonEmptyLines converts given command output string into individual objects
// according to line breakers, and ignores the empty elements in it.
func GetNonEmptyLines(output string) []string <span class="cov0" title="0">{
        var res []string
        elements := strings.Split(output, "\n")
        for _, element := range elements </span><span class="cov0" title="0">{
                if element != "" </span><span class="cov0" title="0">{
                        res = append(res, element)
                }</span>
        }

        <span class="cov0" title="0">return res</span>
}

// GetProjectDir will return the directory where the project is
func GetProjectDir() (string, error) <span class="cov0" title="0">{
        wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return wd, fmt.Errorf("failed to get current working directory: %w", err)
        }</span>
        <span class="cov0" title="0">wd = strings.ReplaceAll(wd, "/test/e2e", "")
        return wd, nil</span>
}

// UncommentCode searches for target in the file and remove the comment prefix
// of the target content. The target content may span multiple lines.
func UncommentCode(filename, target, prefix string) error <span class="cov0" title="0">{
        // false positive
        // nolint:gosec
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file %q: %w", filename, err)
        }</span>
        <span class="cov0" title="0">strContent := string(content)

        idx := strings.Index(strContent, target)
        if idx &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to find the code %q to be uncomment", target)
        }</span>

        <span class="cov0" title="0">out := new(bytes.Buffer)
        _, err = out.Write(content[:idx])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to output: %w", err)
        }</span>

        <span class="cov0" title="0">scanner := bufio.NewScanner(bytes.NewBufferString(target))
        if !scanner.Scan() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                if _, err = out.WriteString(strings.TrimPrefix(scanner.Text(), prefix)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write to output: %w", err)
                }</span>
                // Avoid writing a newline in case the previous line was the last in target.
                <span class="cov0" title="0">if !scanner.Scan() </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if _, err = out.WriteString("\n"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write to output: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if _, err = out.Write(content[idx+len(target):]); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to output: %w", err)
        }</span>

        // false positive
        // nolint:gosec
        <span class="cov0" title="0">if err = os.WriteFile(filename, out.Bytes(), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file %q: %w", filename, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
