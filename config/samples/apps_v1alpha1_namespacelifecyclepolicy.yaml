apiVersion: apps.ops.dev/v1alpha1
kind: NamespaceLifecyclePolicy
metadata:
  labels:
    app.kubernetes.io/name: app-lifecycle-kubernetes-operator
    app.kubernetes.io/managed-by: kustomize
  name: namespacelifecyclepolicy-sample
spec:
  # ============================================================================
  # MANDATORY FIELDS
  # ============================================================================

  # targetNamespace specifies the name of the namespace to which this policy applies.
  # This field is required and must reference an existing namespace.
  targetNamespace: production

  # action defines the lifecycle operation to perform.
  # Valid values: "Freeze", "Resume"
  action: Resume

  # startupPolicy defines the behavior when the operator starts.
  # Valid values: "Ignore", "Resume", "Freeze"
  startupPolicy: Resume

  # ============================================================================
  # OPTIONAL FIELDS
  # ============================================================================

  # operationId is an optional identifier for this operation.
  # Can be used for tracking and correlation purposes.
  # operationId: "op-123456789-2"

  # startupResumeDelay specifies how long to wait before starting the startup Resume operation.
  # ONLY applies to startup (when startupPolicy: Resume triggers).
  # Does NOT apply to manual Resume operations (changing spec.action).
  # Useful for staggering multiple namespace resume operations during cluster startup
  # to prevent simultaneous resume bursts that could overload nodes.
  # Default: 0s (no delay)
  # Example: Use different delays for different namespaces:
  #   namespace-1: startupResumeDelay: 0s    (starts immediately at startup)
  #   namespace-2: startupResumeDelay: 30s   (waits 30 seconds at startup)
  #   namespace-3: startupResumeDelay: 60s   (waits 60 seconds at startup)
  # startupResumeDelay: 0s

  # startupResumePriority defines the priority order for startup resume operations.
  # Lower numbers have higher priority (e.g., 1 is processed before 2).
  # Only applies when startupPolicy is Resume.
  # If not specified, default priority is 100 (processed after all specified priorities).
  # Policies with the same priority are processed in creation order (older first).
  # When combined with startupResumeDelay, policies are processed in priority order,
  # and each policy waits for its delay and resume completion before the next priority starts.
  # Example: Use priority to control processing order:
  #   namespace-1: startupResumePriority: 1, startupResumeDelay: 0s    (processed first, starts immediately)
  #   namespace-2: startupResumePriority: 2, startupResumeDelay: 30s   (processed second, waits 30s after NS-1 completes)
  #   namespace-3: startupResumePriority: 3, startupResumeDelay: 60s   (processed third, waits 60s after NS-2 completes)
  # +optional
  # startupResumePriority: 100  # Default priority (processed after all specified priorities)

  # ============================================================================
  # WORKLOAD SELECTION
  # ============================================================================

  # selector is optional - if not specified, all Deployments and StatefulSets will be affected
  # selector:
  #   matchLabels:
  #     app: myapp
  #     environment: production
  #   matchExpressions:
  #   - key: tier
  #     operator: In
  #     values:
  #     - frontend
  #     - backend

  # ============================================================================
  # POD BALANCING (Resume only)
  # ============================================================================

  # balancePods enables automatic pod redistribution when new nodes become Ready
  # after a Resume operation. Only applies when action is Resume.
  # balancePods: true

  # balanceWindowSeconds defines how long (in seconds) after resume the operator
  # will automatically trigger rolling restarts. Only used if balancePods is true.
  # Default: 600 (10 minutes). Range: 0-3600
  # balanceWindowSeconds: 600

  # ============================================================================
  # GRACEFUL SHUTDOWN (Freeze only)
  # ============================================================================

  # terminationGracePeriodSeconds defines graceful shutdown overrides for different resource types
  # during the Freeze operation. Original values are restored during Resume.
  # Range: 0-300 seconds.
  # terminationGracePeriodSeconds:
  #   deployment: 10
  #   statefulSet: 60

  # ============================================================================
  # NODE READINESS POLICY
  # ============================================================================

  # startupNodeReadinessPolicy defines node readiness requirements before applying startup policy.
  # Only applies when startupPolicy is Resume or Freeze.
  # This helps ensure pods are distributed across all available nodes when operator starts.
  # startupNodeReadinessPolicy:
  #   enabled: true
  #   timeoutSeconds: 120          # Wait max 2 minutes for nodes
  #   requireAllNodes: true        # REQUIRED: true = all nodes, false = use minReadyNodes
  #   minReadyNodes: 2             # Only used when requireAllNodes: false
  #   nodeSelector:
  #     node-role.kubernetes.io/worker: ""

  # ============================================================================
  # ADAPTIVE THROTTLING (Resume only)
  # ============================================================================

  # adaptiveThrottling enables CPU-aware, adaptive batched resume to prevent node overload.
  # The operator monitors 5 levels of signals and adjusts resume speed accordingly:
  #   游댮 Signal 1: Node NotReady (Critical)        - STOP all resume operations and wait
  #   游리 Signal 2: Node Pressure (Warning)         - Significantly reduce batch size (default: 50%)
  #   游릭 Signal 3: Node Resource Allocation (Warning) - PROACTIVE reduction before pressure (default: 60%)
  #   游 Signal 4: Pending Pods (Info)             - Moderately reduce batch size (default: 70%)
  #   游릮 Signal 5: Container Restarts (Warning)     - Detects application-level congestion in targetNamespace (default: 50%)
  #
  # Use this when you have:
  #   - Limited node resources (small clusters)
  #   - Many workloads to resume simultaneously
  #   - Risk of node crashes during resume operations
  #
  # adaptiveThrottling:
  #   enabled: true
  #
  #   # Initial batch size - start with this many workloads at a time
  #   # Default: 3, Min: 1, Max: 20
  #   initialBatchSize: 3
  #
  #   # Minimum batch size - never go below this when slowing down
  #   # Default: 1, Min: 1
  #   minBatchSize: 1
  #
  #   # Wait interval between batches (in seconds)
  #   # Default: 5, Min: 0, Max: 60
  #   batchInterval: 5
  #
  #   # Signal monitoring configuration
  #   signalChecks:
  #     # Signal 1: Node Ready Status (游댮 Critical - STOP)
  #     checkNodeReady:
  #       enabled: true
  #       waitInterval: 20    # Check every 20 seconds when waiting
  #       maxWaitTime: 1800   # Wait max 30 minutes (1800 seconds)
  #
  #     # Signal 2: Node Pressure (游리 Warning - SLOW DOWN)
  #     # Monitors node conditions: MemoryPressure, DiskPressure, PIDPressure
  #     checkNodePressure:
  #       enabled: true
  #       pressureTypes:
  #         - MemoryPressure
  #         - DiskPressure
  #         - PIDPressure
  #         - NetworkUnavailable
  #       slowdownPercent: 50  # Reduce batch size to 50% when pressure detected
  #
  #     # Signal 3: Node Usage (游릭 Warning - PROACTIVE SLOW DOWN)
  #     # PROACTIVE monitoring - detects high resource usage BEFORE nodes become unresponsive
  #     # Monitors: (actual node CPU/memory usage from kubelet / node allocatable) * 100
  #     # Uses kubelet stats API for real-time usage (~10 second lag)
  #     # This prevents nodes from going NotReady by throttling early
  #     checkNodeUsage:
  #       enabled: true
  #       cpuThresholdPercent: 80     # Trigger when any node reaches 80% CPU usage
  #       memoryThresholdPercent: 80  # Trigger when any node reaches 80% memory usage
  #       slowdownPercent: 60         # Reduce batch size to 60% when triggered
  #       # Alternative metrics source for RKE2 or other environments where kubelet stats API doesn't work
  #       # scrape:
  #       #   source: ":9090/metrics"           # Port and path pattern (e.g., ":9090/metrics")
  #       #                                     # Requests will be sent to http://{node-ip}:9090/metrics for each worker node
  #       #   cpu: "cpu_usages.percentage"      # JSON path to extract CPU percentage
  #       #   mem: "memory_usages.percentage"   # JSON path to extract memory percentage
  #       # If source is "kubelet" or not specified, uses default kubelet stats API
  #
  #     # Signal 4: Pending Pods (游 Info - SLOW DOWN)
  #     # CLUSTER-WIDE: Counts resource-constrained pending pods across ALL namespaces
  #     # Only counts pods pending due to RESOURCE CONSTRAINTS (Insufficient cpu/memory/pods)
  #     # Does NOT count pods pending for other reasons (ImagePullBackOff, ContainerCreating, etc.)
  #     checkPendingPods:
  #       enabled: true
  #       threshold: 5          # Trigger if more than 5 pods are resource-pending cluster-wide
  #       slowdownPercent: 70   # Reduce batch size to 70% when triggered
  #
  #     # Signal 5: Container Restarts (游릮 Warning - SLOW DOWN)
  #     # TARGET-NAMESPACE: Detects pods in CrashLoopBackOff or with high restart counts
  #     # Only checks pods in the targetNamespace (not cluster-wide)
  #     # This helps detect logical congestion in your application namespace (e.g. database overload)
  #     checkContainerRestarts:
  #       enabled: true
  #       restartThreshold: 10  # Trigger if a container restarts 10+ times in targetNamespace
  #       slowdownPercent: 50   # Reduce batch size by 50% when triggered
  #
  #   # Which nodes to monitor
  #   nodeSelector:
  #     node-role.kubernetes.io/worker: ""
  #
  #   # Fallback behavior if signals cannot be collected
  #   fallbackOnMetricsUnavailable: true

  # ============================================================================
  # PRE-CONDITIONS (Resume only)
  # ============================================================================

  # preConditions defines requirements that must be met before Resume operations can proceed.
  # Only applies when action is Resume.
  # Checks app readiness and health endpoints before resuming the namespace.
  # preConditions:
  #   enabled: true
  #
  #   # appReadinessChecks lists apps that must be ready before resuming
  #   # Format: "namespace.name" (e.g., "production.database")
  #   # Checks Deployment or StatefulSet readiness (all replicas ready, conditions met)
  #   # The operator will check for Deployment first, then StatefulSet if not found.
  #   appReadinessChecks:
  #     - "infrastructure.database"      # Wait for database in infrastructure namespace
  #     - "infrastructure.redis"           # Wait for redis in infrastructure namespace
  #
  #   # healthEndpointChecks lists HTTP endpoints that must return healthy status
  #   # Format: "http://service-name.namespace.svc.cluster.local:port/path" or "https://..."
  #   # Default: expects 200-299 status codes
  #   healthEndpointChecks:
  #     - url: "http://api.gateway.svc.cluster.local:8080/health"
  #       expectedStatusCodes: [200]
  #       timeoutSeconds: 5
  #
  #   # checkInterval defines how often to check pre-conditions (in seconds)
  #   # Default: 5
  #   checkInterval: 5
  #
  #   # timeoutSeconds is the maximum time to wait for pre-conditions (in seconds)
  #   # If 0 or not set, waits indefinitely
  #   # Default: 0 (wait indefinitely)
  #   timeoutSeconds: 0
